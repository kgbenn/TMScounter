import matplotlib.pyplot as plt
import math
import argparse

# This lookup is used to correlate amino-acids to their
# corresponding Kyte-Doolittle hydropathy score.
hydropathy_lookup = {
    'A':  1.800,
    'R': -4.500,
    'N': -3.500,
    'D': -3.500,
    'C':  2.500,
    'Q': -3.500,
    'E': -3.500,
    'G': -0.400,
    'H': -3.200,
    'I':  4.500,
    'L':  3.800,
    'K': -3.900,
    'M':  1.900,
    'F':  2.800,
    'P': -1.600,
    'S': -0.800,
    'T': -0.700,
    'W': -0.900,
    'Y': -1.300,
    'V':  4.200,
}

# Make sure to at least set --file flag if you aren't working directly out of a BLAST search 
# (hence the 'seqdump.txt' default). Defaults are set for measuring 24TMS Ca & Na.
parser = argparse.ArgumentParser(description='Analyze proteins for a certain number of hydrophobic spanners')
parser.add_argument('--window', default=21, type=int, help='defines the width of the sliding window used')
parser.add_argument('--max', default=26, type=int, help='what is the maximum number of hydrophobic spanners that will be included in the passed group')
parser.add_argument('--min', default=22, type=int, help='what is the minimum number of hydrophobic spanners that will be included in the passed group')
parser.add_argument('--threshold', default=1.0, type=float, help='what hydropathy score is required to consider a spanner as hydrophobic')
parser.add_argument('--file', default='seqdump.txt', type=str, help='path to the data file')
parser.add_argument('--graph', action='store_true', help='should the spanners be graphed?')
parser.add_argument('--log', action='store_true', help='should we log things')
args = parser.parse_args().__dict__

# Variables in program set to argument values.
SLIDING_WINDOW_LENGTH = args['window']
MAX_HYDROPHOBIC_SPANNER_GROUPS = args['max']
MIN_HYDROPHOBIC_SPANNER_GROUPS = args['min']
HYDROPATHY_THRESHOLD = args['threshold']
GRAPH = args['graph']
LOG = args['log']
FILE = args['file']

# Map each amino-acid in the protein sequence to the average hydropathy
# of its SLIDING_WINDOW_LENGTH length of amino-acids.
def generate_spanners(protein_sequence):
    # Store the average hydropathy of each amino acids next SLIDING_WINDOW_LENGTH's
    # amount of amino acids.
    spanners = []

    # Loop over the protein_sequence to analyze each sliding window of amino
    # acids to determine average hydropathy.
    for idx, _ in enumerate(protein_sequence[0:-(SLIDING_WINDOW_LENGTH-1)]):

        # Retrieve spanner.
        spanner = protein_sequence[idx:(idx+SLIDING_WINDOW_LENGTH)]

        total_hydropathy = 0

        # Loop over the spanner to aggregate the hydropathy scores.
        for amino_acid in spanner:
            total_hydropathy += hydropathy_lookup[amino_acid]

        spanners.append(total_hydropathy/SLIDING_WINDOW_LENGTH)

    return spanners


if __name__ == "__main__":
    # Read the 'seqdump.txt' data file.
    data_file = open(FILE, "r") 
    data_string = data_file.read() 

    # Uncomment to generate figure.
    plt.figure()

    protein_data = data_string.split("\n>")

    if LOG:
        print '\n'
        print 'INPUT PROTEINS: \n\t' + str(len(protein_data))
        print '\n'

    passed_proteins = []

    # The data_string needs to be split on '\n>' to account for carrot
    # symbols being located in the protein descriptions.
    for datum_string in protein_data:

        # This handles the case of multiple lingering '>' in the description
        if datum_string is "":
            continue

        # Separate the protein description and sequence using a new line delimiter.
        datum_lines = datum_string.split("\n", 1)
        protein_description = datum_lines[0]

        # The protein sequence needs all Xs removed as they can be intrepeted as
        # 'any' amino acid.
        protein_sequence = "".join(datum_lines[1].splitlines()).replace("X", "")

        # Given len(protein_sequence) number of SLIDING_WINDOW_LENGTHs calculate the average hydropathy value
        # for each sliding window.
        spanners = generate_spanners(protein_sequence)

        # Apply a value of 0 to all spanners that are less than HYDROPATHY_THRESHOLD. This will
        # allow us to later examine chains.
        hydrophobic_spanners = []
        for spanner in spanners:
            hydrophobic_spanners.append(spanner if spanner >= HYDROPATHY_THRESHOLD else 0)

        # This is the crux of the program. The algorithm uses idx+3 because when running initial data through,
        # the highest accuracy while still being inclusive of all 'actual' TMS was generated by this measure.
        # I aired on the side of including more than I needed and cleaning the data with MSA later. Using a
        # smaller measure than idx+3 would not positively affect accuracy and throw off data.
        hydrophobic_spanner_groups_count = 0
        for idx, spanner in enumerate(hydrophobic_spanners[:-(SLIDING_WINDOW_LENGTH+1)]):
            if spanner is not 0 and hydrophobic_spanners[idx+1] is not 0 and hydrophobic_spanners[idx+2] is not 0 and hydrophobic_spanners[idx+3] is 0:
                hydrophobic_spanner_groups_count += 1

        if hydrophobic_spanner_groups_count >= MIN_HYDROPHOBIC_SPANNER_GROUPS and hydrophobic_spanner_groups_count <= MAX_HYDROPHOBIC_SPANNER_GROUPS:
            passed_proteins.append({
                'description': protein_description,
                'sequence': protein_sequence,
                'hydrophobic_spanner_groups_count': hydrophobic_spanner_groups_count
            })

        if GRAPH:
            plt.plot([x for x in range(0, len(spanners)) if hydrophobic_spanners[x] >= HYDROPATHY_THRESHOLD], [x for x in hydrophobic_spanners if x >= HYDROPATHY_THRESHOLD])

    if GRAPH:
        plt.savefig("hydropathy-plot.png")

    if LOG:
        for protein in passed_proteins:
            print '\n'
            print 'DESCRIPTION: \n\t' + protein['description']
            print 'SEQUENCE LENGTH: \n\t' + str(len(protein['sequence']))
            print 'SEQUENCE: \n\t' + protein['sequence']

        print '\n'
        print 'PROTEINS PASSING HYDROPHOBIC SPANNER GROUPS RANGE TEST: \n\t' + str(len(passed_proteins))
        print '\n'

    file = open("output.txt", "w") 
    file.write('\n'.join(['>'+protein['description']+'\n'+protein['sequence'] for protein in passed_proteins])) 
    file.close() 
